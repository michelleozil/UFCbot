arrange(desc(fight_pk)) %>%
select_at(vars(!matches("rev|opp_fighter|res|loss|win"))) %>%
left_join(target_components, by = c("fight_pk", "fighter")) %>%
select_at(vars(contains("target"), everything())) %>%
select(fight_pk, fighter, everything()) %>%
mutate(is_favored = as.factor(is_favored),
strike_favor = as.factor(strike_favor),
sub_favor = as.factor(sub_favor)) %>%
mutate_if(is.numeric, ~replace_na(.x, 0))
# Data partition
set.seed(31)
ind_split <- initial_split(ind_comp_df)
train_ind <- training(ind_split)
test_ind <- testing(ind_split)
k_folds_ind <- vfold_cv(train_ind)
# Neural Network Preparation
train_output <- train_ind %>% select(target_kd, target_sig_strike_landed, target_strike_landed, target_sub_attempts, target_td_landed)
train_input <- train_ind %>% select_at(vars(!matches("target_|fight_pk|fighter")))
test_output <- test_ind %>% select(target_kd, target_sig_strike_landed, target_strike_landed, target_sub_attempts, target_td_landed)
test_input <- test_ind %>% select_at(vars(!matches("target_|fight_pk|fighter")))
neural_network_rec <- recipe(~., data = train_input) %>%
step_YeoJohnson(all_numeric()) %>%
step_range(all_numeric()) %>%
step_dummy(all_nominal(), one_hot = TRUE) %>%
prep()
train_input <- bake(neural_network_rec, new_data = train_input) %>% as.matrix()
test_input <- bake(neural_network_rec, new_data = test_input) %>% as.matrix()
train_output <- as.matrix(train_output)
test_output <- as.matrix(test_output)
# Corrected Neural Network Model using Functional API
input_layer <- layer_input(shape = ncol(train_input))
output_layer <- input_layer %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
model <- keras_model(inputs = input_layer, outputs = output_layer)
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.13154802, 0.42965849, 0.19235573, 0.14902811, 0.09740966)
)
# Load necessary libraries
library(tidyverse)
library(tidymodels)
library(keras)
library(here)
# Load the data
df <- read_csv(here("../Data/fight_data.csv"))
match_df <- read_csv(here("../Data/fights.csv"))
# Prepare individual component data
target_components <- df %>%
select(fight_pk, fighter, round_finished,
kd, sig_strike_attempts, sig_strike_landed,
strike_attempts, strike_landed,
sub_attempts, td_attempts, td_landed) %>%
rename_at(vars(!matches("fight_pk|fighter")), ~paste0("target_", .x)) %>%
mutate(across(-c(fight_pk, fighter, target_round_finished), .fns = ~.x / target_round_finished)) %>%
select(-target_round_finished, -target_strike_attempts, -target_sig_strike_attempts, -target_td_attempts)
ind_comp_df <- match_df %>%
arrange(desc(fight_pk)) %>%
select_at(vars(!matches("rev|opp_fighter|res|loss|win"))) %>%
left_join(target_components, by = c("fight_pk", "fighter")) %>%
select_at(vars(contains("target"), everything())) %>%
select(fight_pk, fighter, everything()) %>%
mutate(is_favored = as.factor(is_favored),
strike_favor = as.factor(strike_favor),
sub_favor = as.factor(sub_favor)) %>%
mutate_if(is.numeric, ~replace_na(.x, 0))
# Data partition
set.seed(31)
ind_split <- initial_split(ind_comp_df)
train_ind <- training(ind_split)
test_ind <- testing(ind_split)
k_folds_ind <- vfold_cv(train_ind)
# Neural Network Preparation
train_output <- train_ind %>% select(target_kd, target_sig_strike_landed, target_strike_landed, target_sub_attempts, target_td_landed)
train_input <- train_ind %>% select_at(vars(!matches("target_|fight_pk|fighter")))
test_output <- test_ind %>% select(target_kd, target_sig_strike_landed, target_strike_landed, target_sub_attempts, target_td_landed)
test_input <- test_ind %>% select_at(vars(!matches("target_|fight_pk|fighter")))
neural_network_rec <- recipe(~., data = train_input) %>%
step_YeoJohnson(all_numeric()) %>%
step_range(all_numeric()) %>%
step_dummy(all_nominal(), one_hot = TRUE) %>%
prep()
train_input <- bake(neural_network_rec, new_data = train_input) %>% as.matrix()
test_input <- bake(neural_network_rec, new_data = test_input) %>% as.matrix()
train_output <- as.matrix(train_output)
test_output <- as.matrix(test_output)
# Corrected Neural Network Model using Functional API
input_shape <- ncol(train_input)
output_shape <- ncol(train_output)
input_layer <- layer_input(shape = input_shape)
output_layer <- input_layer %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = output_shape)
model <- keras_model(inputs = input_layer, outputs = output_layer)
model %>% compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.13154802, 0.42965849, 0.19235573, 0.14902811, 0.09740966)
)
# Load necessary libraries
library(tidyverse)
library(tidymodels)
library(keras)
library(here)
# Load the data
df <- read_csv(here("../Data/fight_data.csv"))
match_df <- read_csv(here("../Data/fights.csv"))
# Prepare individual component data
target_components <- df %>%
select(fight_pk, fighter, round_finished,
kd, sig_strike_attempts, sig_strike_landed,
strike_attempts, strike_landed,
sub_attempts, td_attempts, td_landed) %>%
rename_at(vars(!matches("fight_pk|fighter")), ~paste0("target_", .x)) %>%
mutate(across(-c(fight_pk, fighter, target_round_finished), .fns = ~.x / target_round_finished)) %>%
select(-target_round_finished, -target_strike_attempts, -target_sig_strike_attempts, -target_td_attempts)
ind_comp_df <- match_df %>%
arrange(desc(fight_pk)) %>%
select_at(vars(!matches("rev|opp_fighter|res|loss|win"))) %>%
left_join(target_components, by = c("fight_pk", "fighter")) %>%
select_at(vars(contains("target"), everything())) %>%
select(fight_pk, fighter, everything()) %>%
mutate(is_favored = as.factor(is_favored),
strike_favor = as.factor(strike_favor),
sub_favor = as.factor(sub_favor)) %>%
mutate_if(is.numeric, ~replace_na(.x, 0))
# Data partition
set.seed(31)
ind_split <- initial_split(ind_comp_df)
train_ind <- training(ind_split)
test_ind <- testing(ind_split)
k_folds_ind <- vfold_cv(train_ind)
# Neural Network Preparation
train_output <- train_ind %>% select(target_kd, target_sig_strike_landed, target_strike_landed, target_sub_attempts, target_td_landed)
train_input <- train_ind %>% select_at(vars(!matches("target_|fight_pk|fighter")))
test_output <- test_ind %>% select(target_kd, target_sig_strike_landed, target_strike_landed, target_sub_attempts, target_td_landed)
test_input <- test_ind %>% select_at(vars(!matches("target_|fight_pk|fighter")))
neural_network_rec <- recipe(~., data = train_input) %>%
step_YeoJohnson(all_numeric()) %>%
step_range(all_numeric()) %>%
step_dummy(all_nominal(), one_hot = TRUE) %>%
prep()
train_input <- bake(neural_network_rec, new_data = train_input) %>% as.matrix()
test_input <- bake(neural_network_rec, new_data = test_input) %>% as.matrix()
train_output <- as.matrix(train_output)
test_output <- as.matrix(test_output)
# Corrected Neural Network Model using Functional API
input_shape <- ncol(train_input)
output_shape <- ncol(train_output)
input_layer <- layer_input(shape = input_shape)
output_layer <- input_layer %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = output_shape)
model <- keras_model(inputs = input_layer, outputs = output_layer)
model %>% compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.13154802, 0.42965849, 0.19235573, 0.14902811, 0.09740966)
)
train_output <- train_ind %>% select(target_kd, target_sig_strike_landed, target_strike_landed, target_sub_attempts, target_td_landed)
train_input <- train_ind %>% select_at(vars(!matches("target_|fight_pk|fighter")))
test_output <- test_ind %>% select(target_kd, target_sig_strike_landed, target_strike_landed, target_sub_attempts, target_td_landed)
test_input <- test_ind %>% select_at(vars(!matches("target_|fight_pk|fighter")))
neural_network_rec <- recipe(~., data = train_input) %>%
step_YeoJohnson(all_numeric()) %>%
step_range(all_numeric()) %>%
step_dummy(all_nominal(), one_hot = TRUE) %>%
prep()
train_input <- bake(neural_network_rec, new_data = train_input) %>% as.matrix()
test_input <- bake(neural_network_rec, new_data = test_input) %>% as.matrix()
train_output <- as.matrix(train_output)
test_output <- as.matrix(test_output)
library(tensorflow)
install_tensorflow()
library(tidyverse)
library(keras)
model <- keras_model_sequential() %>%
layer_dense(input_shape = ncol(train_input), units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
reticulate::py_last_error()
knitr::opts_chunk$set(echo = TRUE)
# Load necessary libraries
library(tensorflow)
library(tidyverse)
library(keras)
# Assume train_input and train_output are already defined
# Define the model using the Sequential API with an input layer
model <- keras_model_sequential() %>%
layer_input(shape = ncol(train_input)) %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
reticulate::py_last_error()
install.packages("keras")
knitr::opts_chunk$set(echo = TRUE)
# Load necessary libraries
library(tensorflow)
library(tidyverse)
library(keras)
# Assume train_input and train_output are already defined
# Define the model using the Sequential API with an input layer
model <- keras_model_sequential() %>%
layer_input(shape = ncol(train_input)) %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
install_tensorflow()
knitr::opts_chunk$set(echo = TRUE)
# Load necessary libraries
library(tensorflow)
library(tidyverse)
library(keras)
# Assume train_input and train_output are already defined
# Define the model using the Sequential API with an input layer
model <- keras_model_sequential() %>%
layer_input(shape = ncol(train_input)) %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
reticulate::py_last_error()
# Load necessary libraries
library(tensorflow)
library(tidyverse)
library(keras)
# Assume train_input and train_output are already defined
# Define the model using the Sequential API with input shape in the first layer
model <- keras_model_sequential() %>%
layer_dense(units = 512, activation = "relu", input_shape = ncol(train_input)) %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
# Load necessary libraries
library(tensorflow)
library(tidyverse)
library(keras)
# Assume train_input and train_output are already defined
# Define the model using the Sequential API with an input layer
model <- keras_model_sequential() %>%
layer_input(shape = ncol(train_input)) %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
# Load necessary libraries
library(tensorflow)
library(tidyverse)
library(keras)
# Assume train_input and train_output are already defined
# Define the model using the Sequential API with input shape in the first layer
model <- keras_model_sequential() %>%
layer_dense(units = 512, activation = "relu", input_shape = c(ncol(train_input))) %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
reticulate::py_last_error()
# Load necessary libraries
library(tensorflow)
library(tidyverse)
library(keras)
library(reticulate)
use_virtualenv("r-tensorflow", required = TRUE)
# Assume train_input and train_output are already defined
# Define the model using the Sequential API with input shape in the first layer
model <- keras_model_sequential() %>%
layer_dense(units = 512, activation = "relu", input_shape = c(ncol(train_input))) %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
# Load necessary libraries
library(tidyverse)
library(tidymodels)
library(keras)
# Assume train_input and train_output are already defined
# Define the model using the Sequential API with input shape in the first layer
model <- keras_model_sequential() %>%
layer_dense(units = 512, activation = "relu", input_shape = list(ncol(train_input))) %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
reticulate::py_last_error()
library(reticulate)
use_virtualenv("r-tensorflow", required = TRUE)
# Load necessary libraries
library(tidyverse)
library(tidymodels)
library(keras)
# Assume train_input and train_output are already defined
# Define the model using the Sequential API with input shape in the first layer
model <- keras_model_sequential() %>%
layer_dense(units = 512, activation = "relu", input_shape = c(ncol(train_input))) %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
reticulate::py_last_error()
# Load necessary libraries
library(tidyverse)
library(tidymodels)
library(keras)
# Assume train_input and train_output are already defined
input_shape <- ncol(train_input)
output_shape <- ncol(train_output)
# Define the input layer
input_layer <- layer_input(shape = c(input_shape))
# Define the model using the Functional API within a Sequential model
output_layer <- input_layer %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = output_shape)
# Create the model
model <- keras_model(inputs = input_layer, outputs = output_layer)
# Compile the model
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.13154802, 0.42965849, 0.19235573, 0.14902811, 0.09740966)
)
# Load necessary libraries
library(tidyverse)
library(tidymodels)
library(keras)
library(tensorflow)
# Assume train_input and train_output are already defined
input_shape <- ncol(train_input)
output_shape <- ncol(train_output)
# Define the input layer
input_layer <- layer_input(shape = c(input_shape))
# Define the model using the Functional API
output_layer <- input_layer %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = output_shape)
# Create the model
model <- keras_model(inputs = input_layer, outputs = output_layer)
# Compile the model
model %>% compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.13154802, 0.42965849, 0.19235573, 0.14902811, 0.09740966)
)
library(tensorflow)
install_tensorflow()
library(tidyverse)
library(keras)
model <- keras_model_sequential() %>%
layer_dense(input_shape = ncol(train_input), units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
reticulate::py_last_error()
remove.packages("keras")
install.packages("keras3")
knitr::opts_chunk$set(echo = TRUE)
library(tensorflow)
install_tensorflow()
library(tidyverse)
library(keras3)
model <- keras_model_sequential() %>%
layer_dense(input_shape = ncol(train_input), units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
knitr::opts_chunk$set(echo = TRUE)
library(tensorflow)
install_tensorflow()
library(tidyverse)
library(keras3)
model <- keras_model_sequential() %>%
layer_dense(input_shape = ncol(train_input), units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
knitr::opts_chunk$set(echo = TRUE)
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.13154802, 0.42965849, 0.19235573, 0.14902811, 0.09740966)
)
model <- keras_model_sequential() %>%
layer_dense(input_shape = ncol(train_input), units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.023177977, 0.328520427, 0.10806194, 0.143625994, 0.396613661)
)
history <- model %>% fit(
x = train_input,
y = train_output,
epochs = 200,
validation_split = 0.2,
callbacks = callback_early_stopping(patience = 20)
)
model <- keras_model_sequential() %>%
layer_dense(input_shape = ncol(train_input), units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.023177977, 0.328520427, 0.10806194, 0.143625994, 0.396613661)
)
history <- model %>% fit(
x = train_input,
y = train_output,
epochs = 200,
validation_split = 0.2,
callbacks = callback_early_stopping(patience = 20)
)
reticulate::py_last_error()
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.023177977, 0.328520427, 0.10806194, 0.143625994, 0.396613661)
)
average_loss_weight <- mean(loss_weights)
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.023177977, 0.328520427, 0.10806194, 0.143625994, 0.396613661)
)
average_loss_weight <- mean(loss_weight)
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.023177977, 0.328520427, 0.10806194, 0.143625994, 0.396613661)
)
average_loss_weight <- mean(loss_weights)
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.023177977, 0.328520427, 0.10806194, 0.143625994, 0.396613661),
average_loss_weight <- mean(loss_weights)
)
model <- keras_model_sequential() %>%
layer_dense(input_shape = ncol(train_input), units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = 512, activation = "relu") %>%
layer_dense(units = ncol(train_output))
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.023177977, 0.328520427, 0.10806194, 0.143625994, 0.396613661),
)
history <- model %>% fit(
x = train_input,
y = train_output,
epochs = 200,
validation_split = 0.2,
callbacks = callback_early_stopping(patience = 20)
)
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = c(0.023177977, 0.328520427, 0.10806194, 0.143625994, 0.396613661),
)
model %>%
compile(
optimizer = optimizer_adam(),
loss = "mse",
metrics = list("mean_absolute_error"),
loss_weights = 0.2,
)
history <- model %>% fit(
x = train_input,
y = train_output,
epochs = 200,
validation_split = 0.2,
callbacks = callback_early_stopping(patience = 20)
)
reticulate::py_last_error()
